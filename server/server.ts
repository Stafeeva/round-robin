import express from "express";
import { createServer } from "http";
import path from "path";
import { Server } from "socket.io";

import mysql from "mysql";
import puresql from "puresql";

export type Attendee = { name: string };

export type Note = { author: string; text: string };

export type Action = { assignee: string; text: string };

const connection = mysql.createConnection({
  host: "0.0.0.0",
  port: 3306,
  user: "roundrobin",
  password: "password",
  database: "roundrobin",
});

const adapter = puresql.adapters.mysql(connection, (msg) => console.error(msg));

// see https://github.com/neonerd/puresql for examples
const queries = puresql.loadQueries("server/queries.sql");

const PORT = process.env.PORT || 8000;

const app = express();
const server = createServer(app);
const io = new Server(server);

app.use(express.json());
// Serve the React static files after build
app.use(express.static("../client/build"));

server.listen(PORT, () => {
  console.log(`Server listening on ${PORT}`);
});

const attendees: Attendee[] = [];

const notes: Note[] = [];

const actions: Action[] = [];

enum MeetingState {
  NotStarted = "NotStarted",
  InProgress = "InProgress",
  Ended = "Ended",
}

let meetingState = MeetingState.NotStarted;

// the order in which attendees will speak
let speakerQueue: Attendee[] = [];
let currentSpeaker: Attendee | undefined;

app.get("/api/speaker", async (req, res) => {
  const rows = await queries.get_speakers({}, adapter);
  res.json(rows);
});

app.post("/api/join", (req, res) => {
  console.log(req.body);
  // TODO: Validate the name is unique
  const person = { name: req.body.name };
  attendees.push(person);

  console.log("Attendees", attendees);
  io.emit("meetingUpdated", getMeeting());

  // TODO: what if meeting already started?

  res.json({ message: "joined" });
});

// LIST attendees
app.get("/api/attendee", (req, res) => {
  res.json(attendees);
});

// All other unmatched requests will return the React app
app.get("/", (req, res) => {
  res.sendFile(path.resolve(__dirname, "client", "build", "index.html"));
});

const getMeeting = () => {
  return {
    attendees,
    meetingState,
    speakerQueue,
    currentSpeaker,
  };
};

app.post("/api/meeting", async (req, res) => {
  // create a meeting
  console.log(req.body);

  // TODO: move meeting code functions to a separate file
  const generateMeetingCodeSegment = (length: number): string => {
    const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < length; i++) {
      result += characters.charAt(
        Math.floor(Math.random() * characters.length)
      );
    }
    return result;
  };

  const generateMeetingCode = (): string => {
    // Generate three segments of the code
    const part1 = generateMeetingCodeSegment(3);
    const part2 = generateMeetingCodeSegment(3);
    const part3 = generateMeetingCodeSegment(3);

    // Join the segments with hyphens
    return `${part1}-${part2}-${part3}`;
  };

  const meetingName = req.body.name;

  // validate name
  if (!meetingName) {
    res.status(400).json({ error: "name is required" });
    return;
  }

  const speakerDuration = req.body.speaker_duration || 60;

  if (speakerDuration < 30 || speakerDuration > 300) {
    res
      .status(400)
      .json({ error: "speaker_duration must be between 30 and 300" });
    return;
  }
  const autoProceed = req.body.auto_proceed || false;

  // validate autoProceed is a boolean
  if (typeof autoProceed !== "boolean") {
    res.status(400).json({ error: "auto_proceed must be a boolean" });
    return;
  }

  const meetingState = MeetingState.NotStarted;

  const meetingCode = generateMeetingCode(); // TODO: this can fail if not unique, may need to retry

  const meeting = {
    name: meetingName,
    code: meetingCode,
    speaker_duration: speakerDuration,
    auto_proceed: autoProceed ? 1 : 0, // convert boolean to 0 or 1
    state: meetingState,
    // TODO - speaker queue
  };

  await queries.insert_meeting({ $meeting: meeting }, adapter);

  const meetingId = adapter.lastInsertId;

  // load the meeting that was just saved to the db
  // includes fields that were not present in the request
  // such as meetingId (generated by the db) and other defaults
  // that were not provided
  const savedMeeting = await queries.get_meeting_by_id(
    { id: meetingId },
    adapter
  );

  if (savedMeeting.length === 0) {
    res.status(404).json({ error: "Meeting not found" });
    return;
  }

  console.log("saved meeting", savedMeeting[0]);

  res.status(201).json(savedMeeting[0]);
});

// get meeting by code
app.get("/api/meeting/:code", async (req, res) => {
  const code = req.params.code;

  // validate meeting code correct format
  if (!/^[a-z0-9]{3}-[a-z0-9]{3}-[a-z0-9]{3}$/.test(code)) {
    res.status(400).json({ error: "Invalid meeting code" });
    return;
  }

  const rows = await queries.get_meeting_by_code({ code }, adapter);

  if (rows.length === 0) {
    res.status(404).json({ error: "Meeting not found" });
    return;
  }

  const row = rows[0];

  res.json(row);
});

app.get("/api/meeting", (req, res) => {
  res.json(getMeeting());
});

// TODO: move this to a utility file
const shuffleArray = (array: Attendee[]) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};

// https://cloud.google.com/apis/design/custom_methods

app.post("/api/meeting[:]start", (req, res) => {
  // TODO: only allow starting meeting if in notstarted state

  // Start the meeting
  meetingState = MeetingState.InProgress;
  // Define a random order for the attendees
  speakerQueue = shuffleArray([...attendees]);

  // Start with the first speaker
  currentSpeaker = speakerQueue.shift();

  io.emit("meetingUpdated", getMeeting());

  res.json(getMeeting());
});

app.post("/api/meeting[:]next", (req, res) => {
  // TODO: only allow next if the meeting is in progress

  // Move to the next attendee
  currentSpeaker = speakerQueue.shift();

  // if we have reached the last speaker, the meeting is over
  if (currentSpeaker === undefined) {
    meetingState = MeetingState.Ended;
  }

  io.emit("meetingUpdated", getMeeting());
  res.json(getMeeting());
});

app.post("/api/meeting[:]reset", (req, res) => {
  resetMeeting();

  io.emit("meetingUpdated", getMeeting());
  res.json(getMeeting());
});

const resetMeeting = () => {
  meetingState = MeetingState.NotStarted;
  speakerQueue = [];
  currentSpeaker = undefined;
};

app.get("/api/note", (req, res) => {
  res.json(notes);
});

app.post("/api/note", (req, res) => {
  const note = req.body;
  notes.push(note);
  io.emit("noteAdded", notes);

  res.status(201).json({ message: "Note added" });
});

app.get("/api/action", (req, res) => {
  res.json(actions);
});

app.post("/api/action", (req, res) => {
  const action = req.body;
  actions.push(action);
  io.emit("actionAdded", actions);

  res.status(201).json({ message: "Action added" });
});
